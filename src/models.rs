// Generated by diesel_ext

#![allow(unused)]
#![allow(clippy::all)]

#[cfg(feature = "ssr")]
use crate::schema::*;
use anyhow::{Context, Result};
#[cfg(feature = "ssr")]
use diesel::prelude::*;
use serde::{Deserialize, Serialize};

#[cfg(feature = "ssr")]
pub mod ssr {
    use std::time::{SystemTime, UNIX_EPOCH};

    use super::*;
    use crate::context::GraphQLContext;
    use crate::schema::items::dsl::{done as item_done, items as all_items};
    use crate::schema::users::dsl::{email as users_uname, users as all_users};
    use crate::schema::votes::dsl::{item_uuid, ordinal, user_uuid, votes as all_votes};
    use anyhow::{bail, Context, Result};
    use diesel::{insert_into, prelude::*};
    use itertools::Itertools;
    use uuid::Uuid;

    impl Session {
        pub fn new(context: &GraphQLContext, user: &User) -> Self {
            let mut conn = context.pool.get().expect("Could not get connection");

            let start = SystemTime::now();
            let created = start
                .duration_since(UNIX_EPOCH)
                .expect("Time went backwards");

            let created = created.as_millis();
            let expires = created + (2 * 7 * 24 * 60 * 60 * 1000);

            let created = created as i64;
            let expires = expires as i64;

            let session_uuid = Uuid::new_v4().to_string();

            let session = Session {
                uuid: session_uuid,
                user_uuid: user.uuid.clone(),
                data: None,
                created,
                expires,
            };

            diesel::insert_or_ignore_into(sessions::table)
                .values(&session)
                .execute(&mut conn)
                .expect("Could not create session");

            session
        }

        pub fn get_user(&self, context: &GraphQLContext) -> Result<User> {
            let mut conn = context.pool.get().context("Could not get connection")?;

            users::table
                .filter(users::uuid.eq(&self.user_uuid))
                .first::<User>(&mut conn)
                .context("Could not retrieve user for session")
        }
    }

    impl Election {
        pub fn new(context: &GraphQLContext, name: &str) -> Result<Election> {
            let mut conn = context.pool.get().context("Could not get connection")?;

            let session = context.session.clone();
            if session.is_none() {
                bail!("Not authenticated");
            }
            let user = session
                .unwrap()
                .get_user(context)
                .context("Could not get user from session")?;

            let election = Election {
                uuid: Uuid::new_v4().to_string(),
                owner_uuid: user.uuid.clone(),
                name: name.to_string(),
            };

            diesel::insert_into(elections::table)
                .values(&election)
                .execute(&mut conn)
                .context("Could not insert election")?;

            Self::get(context, &election.uuid)
        }

        pub fn list(context: &GraphQLContext) -> Result<Vec<Election>> {
            if context.session.is_none() {
                bail!("User is not authenticated");
            }

            let user = context
                .session
                .as_ref()
                .unwrap()
                .get_user(context)
                .context("Could not get user session")?;

            let mut conn = context.pool.get().context("Could not get connection")?;

            elections::table
                .filter(elections::owner_uuid.eq(user.uuid))
                .load::<Election>(&mut conn)
                .context("Could not retrieve election")
        }

        pub fn get(context: &GraphQLContext, uuid: &str) -> Result<Election> {
            if context.session.is_none() {
                bail!("User is not authenticated");
            }

            let mut conn = context.pool.get().context("Could not get connection")?;

            elections::table
                .filter(elections::uuid.eq(uuid))
                .first::<Election>(&mut conn)
                .context("Could not retrieve election")
        }
    }

    impl User {
        pub fn get(context: &GraphQLContext, email: &str) -> Result<Self> {
            let mut conn = context.pool.get().context("Could not get connection")?;

            users::table
                .filter(users::email.eq(email))
                .first(&mut conn)
                .context("Could not query for user")
        }
        pub fn login(context: &GraphQLContext, email: &str) -> Result<Self> {
            let mut conn = context.pool.get().expect("Could not get connection");

            User::get(context, email).context("Could not retrieve user")
        }
    }
    impl NewUser {
        pub fn login(self, context: &GraphQLContext) -> User {
            let mut conn = context.pool.get().expect("Could not get connection");

            // ensure that the user exists
            let _ = diesel::insert_into(crate::schema::users::table)
                .values(&self)
                .execute(&mut conn);

            users::table
                .filter(users::email.eq(&self.email))
                .get_result::<User>(&mut conn)
                .unwrap()
        }
    }

    impl Item {
        pub fn add_new(
            context: &GraphQLContext,
            election_uuid: &str,
            title: &str,
            body: &str,
        ) -> Result<Item> {
            let mut conn = context.pool.get().expect("Could not get connection");

            let item = NewItem {
                uuid: Uuid::new_v4().to_string(),
                election_uuid: election_uuid.to_string(),
                title: title.to_string(),
                body: body.to_string(),
            };

            let result_id = insert_into(items::table)
                .values(&item)
                .execute(&mut conn)
                .context("Could not insert")?;

            let item = items::table
                .filter(items::election_uuid.eq(election_uuid))
                .filter(items::title.eq(title))
                .filter(items::body.eq(body))
                .first::<Item>(&mut conn)
                .context("Could not retrieve created value")?;

            Ok(item)
        }
        pub fn list(context: &GraphQLContext, election_uuid: &str) -> Vec<Item> {
            let mut conn = context.pool.get().expect("Could not get connection");

            all_items
                .filter(crate::schema::items::done.eq(false))
                .filter(items::election_uuid.eq(election_uuid))
                .load::<Item>(&mut conn)
                .unwrap()
        }
        pub fn for_user(
            context: &GraphQLContext,
            user_id: &str,
            election_uuid: &str,
        ) -> Vec<(Item, Option<i32>)> {
            let mut conn = context.pool.get().expect("Could not get connection");

            all_items
                .left_join(
                    crate::schema::votes::table
                        .on(user_uuid.eq(&user_id).and(item_uuid.eq(items::uuid))),
                )
                .filter(crate::schema::items::done.eq(false))
                .filter(items::election_uuid.eq(election_uuid))
                .order((user_uuid.desc(), ordinal.asc()))
                .select((crate::schema::items::all_columns, ordinal.nullable()))
                .load::<(Item, Option<i32>)>(&mut conn)
                .unwrap()
        }
    }

    impl Vote {
        pub fn run_elections(
            context: &GraphQLContext,
            election_uuid: &str,
        ) -> (Option<Item>, Option<Item>) {
            let winner = Self::run_election(context, election_uuid);
            let runner_up = Self::run_second_election(context, election_uuid, &winner);

            (winner, runner_up)
        }
        pub fn run_election(context: &GraphQLContext, election_uuid: &str) -> Option<Item> {
            let mut conn = context.pool.get().expect("Could not get connection");

            let votes: Vec<Vote> = all_votes
                .inner_join(items::table)
                .filter(item_done.eq(false))
                .filter(items::election_uuid.eq(election_uuid))
                .order((user_uuid.asc(), ordinal.asc()))
                .select((votes::election_uuid, user_uuid, item_uuid, ordinal))
                .load::<Vote>(&mut conn)
                .unwrap();

            // the extra collections here are sad.
            let votes: Vec<Vec<_>> = votes
                .into_iter()
                .group_by(|v| v.user_uuid.clone())
                .into_iter()
                .map(|(_, ballot)| ballot.into_iter().map(|v| v.item_uuid).collect())
                .collect();

            match rcir::run_election(&votes, rcir::MajorityMode::RemainingMajority).ok()? {
                rcir::ElectionResult::Winner(ref iid) => {
                    Some(all_items.find(iid).get_result::<Item>(&mut conn).unwrap())
                }
                rcir::ElectionResult::Tie(iids) => {
                    // TODO: maybe pick the oldest one?
                    Some(
                        all_items
                            .find(iids[0].clone())
                            .get_result::<Item>(&mut conn)
                            .unwrap(),
                    )
                }
            }
        }

        pub fn run_second_election(
            context: &GraphQLContext,
            election_uuid: &str,
            winner: &Option<Item>,
        ) -> Option<Item> {
            let mut conn = context.pool.get().expect("Could not get connection");
            let winner = winner.as_ref()?;

            let votes = all_votes
                .inner_join(items::table)
                .filter(item_done.eq(false))
                .filter(item_uuid.ne(winner.uuid.clone()))
                .filter(items::election_uuid.eq(election_uuid))
                .order((user_uuid.asc(), ordinal.asc()))
                .select((votes::election_uuid, user_uuid, item_uuid, ordinal))
                .get_results::<Vote>(&mut conn)
                .unwrap();

            // the extra collections here are sad.
            let votes: Vec<Vec<_>> = votes
                .into_iter()
                .group_by(|v| v.user_uuid.clone())
                .into_iter()
                .map(|(_, ballot)| ballot.into_iter().map(|v| v.item_uuid.clone()).collect())
                .collect();

            match rcir::run_election(&votes.clone(), rcir::MajorityMode::RemainingMajority).ok()? {
                rcir::ElectionResult::Winner(ref iid) => {
                    Some(all_items.find(iid).get_result::<Item>(&mut conn).unwrap())
                }
                rcir::ElectionResult::Tie(iids) => {
                    // TODO: maybe pick the oldest one?
                    Some(
                        all_items
                            .find(iids[0].clone())
                            .get_result::<Item>(&mut conn)
                            .unwrap(),
                    )
                }
            }
        }

        pub fn save_ballot(context: &GraphQLContext, ballot: &Ballot) -> Result<usize> {
            let user = context.session.as_ref().unwrap().get_user(context).unwrap();
            let mut conn = context.pool.get().expect("Could not get connection");

            diesel::delete(
                all_votes
                    .filter(votes::election_uuid.eq(ballot.election_uuid.clone()))
                    .filter(user_uuid.eq(&user.uuid)),
            )
            .execute(&mut conn)
            .unwrap();

            let ballots: Vec<Vote> = ballot
                .votes
                .iter()
                .enumerate()
                .map(|(i, iid)| Vote {
                    election_uuid: ballot.election_uuid.clone(),
                    user_uuid: user.uuid.to_owned(),
                    item_uuid: iid.to_owned(),
                    ordinal: i as i32,
                })
                .collect();

            diesel::insert_into(crate::schema::votes::table)
                .values(&ballots)
                .execute(&mut conn)
                .context("Could not insert votes")
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[cfg_attr(feature = "ssr", derive(Queryable, Insertable))]
pub struct Session {
    pub uuid: String,
    pub user_uuid: String,
    pub created: i64,
    pub expires: i64,
    pub data: Option<String>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[cfg_attr(feature = "ssr", derive(Queryable, Insertable))]
pub struct Item {
    pub uuid: String,
    pub election_uuid: String,
    pub title: String,
    pub body: String,
    pub done: bool,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "ssr", derive(Queryable, Insertable))]
pub struct User {
    pub uuid: String,
    pub email: String,
    #[serde(skip_serializing)]
    pub password_hash: String,
}

#[derive(Debug, Clone)]
#[cfg_attr(feature = "ssr", derive(Queryable, Insertable))]
#[cfg_attr(feature = "ssr", diesel(primary_key(user_id, item_id)))]
pub struct Vote {
    pub election_uuid: String,
    pub user_uuid: String,
    pub item_uuid: String,
    pub ordinal: i32,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Ballot {
    pub election_uuid: String,
    #[serde(default)]
    pub votes: Vec<String>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[cfg_attr(feature = "ssr", derive(Queryable, Insertable))]
pub struct Election {
    pub uuid: String,
    pub name: String,
    pub owner_uuid: String,
}

#[cfg_attr(feature = "ssr", derive(Queryable, Insertable))]
#[cfg_attr(feature = "ssr", diesel(table_name = crate::schema::users))]
pub struct NewUser {
    pub email: String,
    pub password_hash: String,
}

#[cfg_attr(feature = "ssr", derive(Insertable))]
#[cfg_attr(feature = "ssr", diesel(table_name = crate::schema::items))]
pub struct NewItem {
    pub uuid: String,
    pub election_uuid: String,
    pub title: String,
    pub body: String,
}
