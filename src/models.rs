// Generated by diesel_ext

#![allow(unused)]
#![allow(clippy::all)]

#[cfg(feature = "ssr")]
use crate::schema::*;
use anyhow::{Context, Result};
#[cfg(feature = "ssr")]
use diesel::prelude::*;
use serde::{Deserialize, Serialize};

#[cfg(feature = "ssr")]
pub mod ssr {
    use super::*;
    use crate::context::GraphQLContext;
    use crate::schema::items::dsl::{done as item_done, items as all_items};
    use crate::schema::users::dsl::{username as users_uname, users as all_users};
    use crate::schema::votes::dsl::{item_id, ordinal, user_id, votes as all_votes};
    use diesel::{insert_into, prelude::*};
    use itertools::Itertools;

    impl User {
        pub fn get(context: &GraphQLContext, username: &str) -> Result<Self> {
            let mut conn = context.pool.get().context("Could not get connection")?;

            users::table
                .filter(users::username.eq(username))
                .first(&mut conn)
                .context("Could not query for user")
        }
        pub fn login(context: &GraphQLContext, username: &str) -> Result<Self> {
            let mut conn = context.pool.get().expect("Could not get connection");

            User::get(context, username).context("Could not retrieve user")
        }
    }
    impl NewUser {
        pub fn login(self, context: &GraphQLContext) -> User {
            let mut conn = context.pool.get().expect("Could not get connection");

            // ensure that the user exists
            let _ = diesel::insert_into(crate::schema::users::table)
                .values(&self)
                .execute(&mut conn);

            users::table
                .filter(users::username.eq(&self.username))
                .get_result::<User>(&mut conn)
                .unwrap()
        }
    }

    impl Item {
        pub fn add_new(context: &GraphQLContext, title: &str, body: &str) -> Result<Item> {
            let mut conn = context.pool.get().expect("Could not get connection");

            let item = NewItem {
                title: title.to_string(),
                body: body.to_string(),
            };

            let result_id = insert_into(items::table)
                .values(&item)
                .execute(&mut conn)
                .context("Could not insert")?;

            let item = items::table
                .filter(items::title.eq(title))
                .filter(items::body.eq(body))
                .first::<Item>(&mut conn)
                .context("Could not retrieve created value")?;

            Ok(item)
        }
        pub fn list(context: &GraphQLContext) -> Vec<Item> {
            let mut conn = context.pool.get().expect("Could not get connection");

            all_items
                .filter(crate::schema::items::done.eq(false))
                .load::<Item>(&mut conn)
                .unwrap()
        }
        pub fn for_user(uid: i32, context: &GraphQLContext) -> Vec<(Item, Option<i32>)> {
            let mut conn = context.pool.get().expect("Could not get connection");

            all_items
                .left_join(
                    crate::schema::votes::table.on(user_id.eq(&uid).and(item_id.eq(items::id))),
                )
                .filter(crate::schema::items::done.eq(false))
                .order((user_id.desc(), ordinal.asc()))
                .select((crate::schema::items::all_columns, ordinal.nullable()))
                .load::<(Item, Option<i32>)>(&mut conn)
                .unwrap()
        }
    }

    impl Vote {
        pub fn run_election(context: &GraphQLContext) -> Option<Item> {
            let mut conn = context.pool.get().expect("Could not get connection");

            let votes: Vec<Vote> = all_votes
                .inner_join(items::table)
                .filter(item_done.eq(false))
                .order((user_id.asc(), ordinal.asc()))
                .select((user_id, item_id, ordinal))
                .load::<Vote>(&mut conn)
                .unwrap();

            // the extra collections here are sad.
            let votes: Vec<Vec<_>> = votes
                .into_iter()
                .group_by(|v| v.user_id)
                .into_iter()
                .map(|(_, ballot)| ballot.into_iter().map(|v| v.item_id).collect())
                .collect();

            match rcir::run_election(&votes, rcir::MajorityMode::RemainingMajority).ok()? {
                rcir::ElectionResult::Winner(&iid) => {
                    Some(all_items.find(iid).get_result::<Item>(&mut conn).unwrap())
                }
                rcir::ElectionResult::Tie(iids) => {
                    // TODO: maybe pick the oldest one?
                    Some(
                        all_items
                            .find(*iids[0])
                            .get_result::<Item>(&mut conn)
                            .unwrap(),
                    )
                }
            }
        }

        pub fn run_second_election(
            context: &GraphQLContext,
            winner: &Option<Item>,
        ) -> Option<Item> {
            let mut conn = context.pool.get().expect("Could not get connection");
            let winner = winner.as_ref()?;

            let votes = all_votes
                .inner_join(items::table)
                .filter(item_done.eq(false))
                .filter(item_id.ne(winner.id))
                .order((user_id.asc(), ordinal.asc()))
                .select((user_id, item_id, ordinal))
                .get_results::<Vote>(&mut conn)
                .unwrap();

            // the extra collections here are sad.
            let votes: Vec<Vec<_>> = votes
                .into_iter()
                .group_by(|v| v.user_id)
                .into_iter()
                .map(|(_, ballot)| ballot.into_iter().map(|v| v.item_id).collect())
                .collect();

            match rcir::run_election(&votes, rcir::MajorityMode::RemainingMajority).ok()? {
                rcir::ElectionResult::Winner(&iid) => {
                    Some(all_items.find(iid).get_result::<Item>(&mut conn).unwrap())
                }
                rcir::ElectionResult::Tie(iids) => {
                    // TODO: maybe pick the oldest one?
                    Some(
                        all_items
                            .find(*iids[0])
                            .get_result::<Item>(&mut conn)
                            .unwrap(),
                    )
                }
            }
        }

        pub fn save_ballot(uid: i32, ballot: &Ballot, context: &GraphQLContext) {
            let mut conn = context.pool.get().expect("Could not get connection");

            diesel::delete(all_votes.filter(user_id.eq(&uid)))
                .execute(&mut conn)
                .unwrap();

            for (i, iid) in ballot.votes.iter().enumerate() {
                diesel::insert_into(crate::schema::votes::table)
                    .values(Vote {
                        user_id: uid,
                        item_id: *iid,
                        ordinal: i as i32,
                    })
                    .execute(&mut conn)
                    .unwrap();
            }
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
#[cfg_attr(feature = "ssr", derive(Identifiable, Queryable, Insertable))]
pub struct Item {
    pub id: i32,
    pub title: String,
    pub body: String,
    pub done: bool,
}

#[derive(Clone, Deserialize, Serialize, Debug)]
#[cfg_attr(feature = "ssr", derive(Identifiable, Queryable, Insertable))]
pub struct User {
    pub id: i32,
    pub username: String,
}

#[derive(Debug)]
#[cfg_attr(feature = "ssr", derive(Queryable, Identifiable, Insertable))]
#[cfg_attr(feature = "ssr", diesel(primary_key(user_id, item_id)))]
pub struct Vote {
    pub user_id: i32,
    pub item_id: i32,
    pub ordinal: i32,
}

#[derive(Clone, Deserialize, Serialize)]
pub struct Ballot {
    pub votes: Vec<i32>,
}

#[cfg_attr(feature = "ssr", derive(Queryable, Insertable))]
#[cfg_attr(feature = "ssr", diesel(table_name = crate::schema::users))]
pub struct NewUser {
    pub username: String,
}

#[cfg_attr(feature = "ssr", derive(Insertable))]
#[cfg_attr(feature = "ssr", diesel(table_name = crate::schema::items))]
pub struct NewItem {
    pub title: String,
    pub body: String,
}
